# Theming



### The Basics

Our two main component libraries, [Vanilla Components](/component-libraries/vanilla/introduction) and [Remarkable Pro](/component-libraries/remarkable-pro/introduction), both leverage Embeddableâ€™s theming system to provide a consistent look and feel across all components. The theme is defined in your repo in `embeddable.theme.ts` at the root level, and is where you can set colors, fonts, and other styling options that will apply globally to all components.

<Callout icon="âš ï¸">
The rest of this documentation assumes you're using [Remarkable Pro](/component-libraries/remarkable-pro/introduction). If you'd like to learn more about theming in [Vanilla Components](/component-libraries/vanilla/introduction), please see the [Vanilla Components Theming documentation](/component-libraries/vanilla/theming).
</Callout>

### Single Theme

If you just want to have a single theme, itâ€™s a very straightforward process! Youâ€™ll need to find `embeddable.theme.ts` at the root level of the [Boilerplate Repo](https://github.com/embeddable-hq/remarkable-pro-boilerplate). It should look something like this:

```tsx
//embeddable.theme.ts
import { defineTheme } from "@embeddable.com/core";
import { Theme, DeepPartial } from "@embeddable.com/remarkable-pro";
import { darkTheme } from "./dark-theme";

const themeProvider = (clientContext: any, parentTheme: Theme): Theme => {
  const newTheme: DeepPartial<Theme> =
    clientContext.theme === "dark" ? darkTheme : {};
  const theme = defineTheme(parentTheme, newTheme) as Theme;
  return theme;
};

export default themeProvider;
```

Letâ€™s break down whatâ€™s happening here. We're importing `defineTheme`, which is a helper function that merges your custom theme values with the default theme provided by Embeddable. This way, you only need to specify the values you want to change, and the rest will fall back to the defaults.

To create your own theme, youâ€™ll want to modify the `newTheme` object. This is where you can specify your custom styles, or import a separate theme file if you prefer to keep things organized.

We then return the merged theme using `defineTheme(parentTheme, newTheme)`, which combines your customizations with the existing theme. This allows you to overwrite as many or as few properties as you like.

<Callout emoji="ðŸ’¡">
Want more detail on Remarkable Pro's theming system? Check out the [Remarkable Pro Theming documentation](/component-libraries/remarkable-pro/theming) for a deeper dive.
</Callout>

### Multiple Themes With Client Context

If youâ€™re looking to support multiple themes, there are two separate approaches you can take: create multiple theme files, import them, and switch between them based on [client context](/development/client-context), or pass the theme values directly in client context.

**Using Theme File Imports**

This is the approach taken in the boilerplate repo above. You can create as many theme files as you like, each exporting a `DeepPartial<Theme>` object. You can then use client context to determine which theme to apply.

We encourage you to adjust the `ClientContext` interface to include any other values youâ€™re passing in via Client Context, especially if you intend to use them in this file in any way (for example, you could pass a set of chart colors via Client Context and then plug them into the theme, for a hybrid between this approach and the one below).

**Sending Theme Objects Via Client Context**

If youâ€™re going to support more than a handful of themes, for example, if you want to have a theme for each of your own clients, it will likely be a lot of work to create and support a large number of theme files. You may also already have theme data for clients stored in a database, or other location, and want to repurpose that data rather than manually crafting themes. In either case, the great thing about [Client Context](/development/client-context) is itâ€™s just arbitrary JSON, and our theme files are just a JavaScript object, so itâ€™s very straightforward to combine the two. Hereâ€™s what it might look like:

```tsx
// your front-end code
<em-beddable token={{securityToken}} clientContext={{
  theme: {
    // Various theme values as described in the Remarkable Pro theming docs
  }
}} />
```

```tsx
// embeddable.theme.ts
import { Theme, defineTheme } from '@embeddable.com/vanilla-components';

const themeProvider = (clientContext: any, parentTheme: Theme): Theme => {
  const { theme } = clientContext;
	return defineTheme(parentTheme, theme);
};

export default themeProvider;
```

This approach would support as many themes as youâ€™d like, and the theme objects you send can be a few overrides or all of the data needed to completely change every aspect of the theme! 

**Theme Provider**

If youâ€™re writing your own components, or if youâ€™ve modified our existing components and need to bring them in as overrides (as described above), youâ€™ll need to use the theme provider to get values from your theme.

Many charts and graphs need to be provided with direct values rather than CSS. Fortunately, thatâ€™s no problem. With this change comes a new hook you can use in your components, the aptly-named `useTheme`. Hereâ€™s an abbreviated version of how to use it.

```tsx
import { useTheme } from '@embeddable.com/react';

type Theme = {
  // Your theme shape here
}


const MyComponent = () => {
  const theme: Theme = useTheme() as Theme;
  const dateRangeOptions = theme.defaults.dateRangesOptions;
  // Use dateRangeOptions in your component
  return <div>...</div>;
};
```

As you can see, accessing theme values in your own components is simple: use the hook to set a `theme` object, then reference the properties on that object as youâ€™d expect.

Please note: `useTheme` runs before render, unlike most React hooks, so you will *always* have access to a theme if you have one defined.
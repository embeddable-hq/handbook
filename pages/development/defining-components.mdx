# Defining Components

You can create **custom React components** in Embeddable using any JS libraries you like. 

Key capabilities include:

- **Define Inputs**: Make re-usable components by defining inputs your team can customize in the builder.
- **Load Data**: Dynamically fetch data from your database via Embeddable's [`loadData`](/development/loading-data) function.
- **Pass Events**: Capture user actions (e.g. button clicks) and send them back to Embeddable for interactive features like filtering. 

## How It Works

<Steps>

### **Build Your React Component (`.tsx`)**  
  Write a **standard React component** - handling your UI, props, and business logic.  

  For example, this simple **text component** displays a title and body:

  ```tsx
  // src/components/TextComponent/index.tsx

  import React from 'react';

  type Props = {
    title: string;
    body: string;
  };

  export default ({ title, body }: Props) => {
    return (
      <div>
        <h1>{title}</h1>
        <p>{body}</p>
      </div>
    );
  };
  ```

  There's nothing Embeddable-specific about this code - it's just standard React. 

### **Configure in `.emb.ts`**  
  In a **companion `.emb.ts` file**, define **inputs** and other configuration, including how to [load data](/development/loading-data). This file tells Embeddable **how** to expose the component in the no-code builder so it can be configured by your team without code:

  ```tsx
  // src/components/TextComponent/TextComponent.emb.ts

  import { EmbeddedComponentMeta, defineComponent } from '@embeddable.com/react';
  import Component from './index';
  import { Inputs } from '@embeddable.com/react';

  export const meta = {
    name: 'TextComponent', // a unique identifier that must match the file name (i.e. TextComponent.emb.ts)
    label: 'Text component', // user-facing name in the builder
    inputs: [
      {
        name: 'title', // unique identifier for this input
        type: 'string',  // determines the UI control to render (i.e. a text field in this case)
        label: 'Title', // the label shown in the builder
      },
      {
        name: 'body', // unique identifier for this input
        type: 'string', // renders a second text field. 
        label: 'Body', // the label shown in the builder
      }
    ]
  } as const satisfies EmbeddedComponentMeta;

  //The function that tells the SDK to include this component in the no-code builder.
  export default defineComponent(Component, meta, {
    props: (inputs: Inputs<typeof meta>) => {
      return {
        // the inputs are passed through to the React component as props
        title: inputs.title,
        body: inputs.body
      };
    }
  });
  ```

Two things to notice:
1. `inputs` tells Embeddable which input fields to show in the UI when using this component.  In this case, two text input fields.
2. `props` is a function that takes those `inputs` and maps them onto the `props` that should be passed into the React component when rendering.

<a name="push-to-embeddable"></a>
### **Push to Embeddable**  
  Run `npm run embeddable:dev` to test out your component, and when you’re happy with it, [**push**](/development/pushing-code) your component code to Embeddable. Your teammates can now **drag, drop, and configure** it in their dashboards - no extra coding required.

  <ImageGrid images={["/img/hello-world-edit.png", "/img/hello-world-component.png"]} />


<a name="define-additional-inputs"></a>
### **Define Additional Inputs per Dimension/Measure** (optional)

Some inputs may directly reference the **dimensions** and **measures** you've defined in your data models. This might be fine for a bar graph, for example, where you're showing dates and a count, so the data is already easy for people to read. In other cases, you may find that the dimension name is not particularly user-friendly. As an example, your table component might display multiple columns of dimensions of metrics with names like `signed_up_date` or `total_revenue_by_month`, or even more esoteric/unreadable names like `ekp_mod_rev_mon`. In these cases, you can define additional inputs that will be used to display the data in a more user-friendly way.

The way Embeddable allows you to do this is by defining an additional `inputs` array within any given item the top-level `inputs` array. Here's a quick example:

```tsx
    {
      name: 'columns',
      type: 'dimensionOrMeasure',
      label: 'Columns',
      array: true,
      inputs: [
        {
          name: 'label',
          type: 'string',
          label: 'Label name',
          description: 'The label to show on this column',
          required: false,
        },
        {
          name: 'suffix',
          type: 'string',
          supportedTypes: ['number', 'string'],
          label: 'Suffix',
        },
      ],
      config: {
        dataset: 'ds',
      },
      category: 'Chart data',
    },
```

 When you do this, the Embeddable SDK recognizes it and will automatically create expandable inputs in the builder UI. The available sub-input types are:

| **Param**       | **Type**                                | **Required** |
| --------------- | --------------------------------------- | ------------ |
| `name`          | string                                  | ✅ Yes       |
| `type`          | `CustomType` or `NativeType`            | ✅ Yes       |
| `label`         | string                                  | ✅ Yes       |
| `description`   | string                                  | ❌ No        |
| `defaultValue`  | string                                  | ❌ No        |
| `config`        | [Config](/development/defining-components#3-config)                                  | ❌ No        |
| `required`      | boolean                                 | ❌ No        |
| `supportedTypes`| array of strings                        | ❌ No        |

Once defined, these sub-inputs will be displayed in the builder UI, and the values the user puts into them will be passed to your component as props, just like the top-level inputs. To learn more about how to use them, you can check our [Component Examples page](/development/component-examples).

</Steps>

## Futher Reading

You may have noticed that `defineComponent` function we're using in the `.emb.ts` file. This is a utility function that allows you not only to return your inputs as props to your component, but to work with them beforehand, allowing you to customize the final values that reach your component. You can [learn more about it here](/development/defining-components/define-component).

The `loadData` function used above is one of the **most powerful** parts of the Embeddable SDK. You can [learn more about it here](/development/loading-data).

You can see detailed examples of how we create components in the [Component Examples](/development/component-examples) section.
